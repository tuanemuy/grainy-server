-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE TABLE IF NOT EXISTS public.posts
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone,
    user_id uuid NOT NULL,
    text text COLLATE pg_catalog."default",
    reblog_id bigint,
    reply_id bigint,
    CONSTRAINT posts_pkey PRIMARY KEY (id),
    CONSTRAINT posts_reblog_id_fkey FOREIGN KEY (reblog_id)
        REFERENCES public.posts (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT posts_reply_id_fkey FOREIGN KEY (reply_id)
        REFERENCES public.posts (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT posts_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

CREATE INDEX index_posts_user_id ON public.posts (user_id) TABLESPACE pg_default;
CREATE INDEX index_posts_reply_id ON public.posts (reply_id) TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.posts
    OWNER to postgres;

ALTER TABLE IF EXISTS public.posts
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.posts TO anon;

GRANT ALL ON TABLE public.posts TO authenticated;

GRANT ALL ON TABLE public.posts TO postgres;

GRANT ALL ON TABLE public.posts TO service_role;
CREATE POLICY "Enable delete for users based on user_id"
    ON public.posts
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY "Enable insert for users based on user_id"
    ON public.posts
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = user_id));
CREATE POLICY "Enable read access for all users"
    ON public.posts
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.tags
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    name text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT tags_pkey PRIMARY KEY (id),
    CONSTRAINT tags_name_key UNIQUE (name)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.tags
    OWNER to postgres;

ALTER TABLE IF EXISTS public.tags
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.tags TO anon;

GRANT ALL ON TABLE public.tags TO authenticated;

GRANT ALL ON TABLE public.tags TO postgres;

GRANT ALL ON TABLE public.tags TO service_role;
CREATE POLICY "Enable insert for authenticated users only"
    ON public.tags
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (true);
CREATE POLICY "Enable read access for all users"
    ON public.tags
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.users_tags
(
    created_at timestamp with time zone DEFAULT now(),
    user_id uuid NOT NULL,
    tag_id bigint NOT NULL,
    CONSTRAINT users_tags_pkey PRIMARY KEY (user_id, tag_id),
    CONSTRAINT users_tags_tag_id_fkey FOREIGN KEY (tag_id)
        REFERENCES public.tags (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT users_tags_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

CREATE INDEX index_users_tags_user_id ON public.users_tags (user_id) TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.users_tags
    OWNER to postgres;

ALTER TABLE IF EXISTS public.users_tags
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.users_tags TO anon;

GRANT ALL ON TABLE public.users_tags TO authenticated;

GRANT ALL ON TABLE public.users_tags TO postgres;

GRANT ALL ON TABLE public.users_tags TO service_role;
CREATE POLICY "Enable delete for users based on user_id"
    ON public.users_tags
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY "Enable insert for users based on user_id"
    ON public.users_tags
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = user_id));

CREATE TABLE IF NOT EXISTS public.favorites
(
    created_at timestamp with time zone DEFAULT now(),
    user_id uuid NOT NULL,
    post_id bigint NOT NULL,
    CONSTRAINT favorites_pkey PRIMARY KEY (user_id, post_id),
    CONSTRAINT favorites_post_id_fkey FOREIGN KEY (post_id)
        REFERENCES public.posts (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT favorites_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

CREATE INDEX index_favorites_user_id ON public.favorites (user_id) TABLESPACE pg_default;
CREATE INDEX index_favorites_post_id ON public.favorites (post_id) TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.favorites
    OWNER to postgres;

ALTER TABLE IF EXISTS public.favorites
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.favorites TO anon;

GRANT ALL ON TABLE public.favorites TO authenticated;

GRANT ALL ON TABLE public.favorites TO postgres;

GRANT ALL ON TABLE public.favorites TO service_role;
CREATE POLICY "Enable delete for users based on user_id"
    ON public.favorites
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY "Enable insert for users based on user_id"
    ON public.favorites
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = user_id));
CREATE POLICY "Enable read access for authenticated users only"
    ON public.favorites
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (true);
CREATE POLICY "Enable update for users based on user_id"
    ON public.favorites
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = user_id))
    WITH CHECK ((auth.uid() = user_id));

CREATE TABLE IF NOT EXISTS public.post_metas
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    post_id bigint NOT NULL,
    has_media boolean NOT NULL DEFAULT false,
    CONSTRAINT post_metas_pkey PRIMARY KEY (id),
    CONSTRAINT post_metas_post_id_fkey FOREIGN KEY (post_id)
        REFERENCES public.posts (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.post_metas
    OWNER to postgres;

ALTER TABLE IF EXISTS public.post_metas
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.post_metas TO anon;

GRANT ALL ON TABLE public.post_metas TO authenticated;

GRANT ALL ON TABLE public.post_metas TO postgres;

GRANT ALL ON TABLE public.post_metas TO service_role;
CREATE POLICY "Enable insert for authenticated users only"
    ON public.post_metas
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (true);
CREATE POLICY "Enable read access for all users"
    ON public.post_metas
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.follows
(
    created_at timestamp with time zone DEFAULT now(),
    user_id uuid NOT NULL,
    target_user_id uuid NOT NULL,
    CONSTRAINT follows_pkey PRIMARY KEY (user_id, target_user_id),
    CONSTRAINT follows_target_user_id_fkey FOREIGN KEY (target_user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT follows_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

CREATE INDEX index_follows_user_id ON public.follows (user_id) TABLESPACE pg_default;
CREATE INDEX index_follows_target_user_id ON public.follows (target_user_id) TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.follows
    OWNER to postgres;

ALTER TABLE IF EXISTS public.follows
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.follows TO authenticated;

GRANT ALL ON TABLE public.follows TO anon;

GRANT ALL ON TABLE public.follows TO service_role;

GRANT ALL ON TABLE public.follows TO postgres;
CREATE POLICY "Enable delete for users based on user_id"
    ON public.follows
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY "Enable insert for users based on user_id"
    ON public.follows
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = user_id));
CREATE POLICY "Enable read access for authenticated users only"
    ON public.follows
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (true);

CREATE TABLE IF NOT EXISTS public.profiles
(
    created_at timestamp with time zone DEFAULT now(),
    username text COLLATE pg_catalog."default" NOT NULL,
    name text COLLATE pg_catalog."default",
    id uuid NOT NULL,
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT profiles_username_key UNIQUE (username),
    CONSTRAINT profiles_id_fkey FOREIGN KEY (id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.profiles
    OWNER to postgres;

ALTER TABLE IF EXISTS public.profiles
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.profiles TO anon;

GRANT ALL ON TABLE public.profiles TO authenticated;

GRANT ALL ON TABLE public.profiles TO postgres;

GRANT ALL ON TABLE public.profiles TO service_role;
CREATE POLICY "Enable insert for users based on user_id"
    ON public.profiles
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = id));
CREATE POLICY "Enable read access for all users"
    ON public.profiles
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Enable update for users based on user_id"
    ON public.profiles
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = id))
    WITH CHECK ((auth.uid() = id));

CREATE TABLE IF NOT EXISTS public.posts_tags
(
    created_at timestamp with time zone DEFAULT now(),
    post_id bigint NOT NULL,
    tag_id bigint NOT NULL,
    CONSTRAINT posts_tags_pkey PRIMARY KEY (post_id, tag_id),
    CONSTRAINT posts_tags_post_id_fkey FOREIGN KEY (post_id)
        REFERENCES public.posts (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT posts_tags_tag_id_fkey FOREIGN KEY (tag_id)
        REFERENCES public.tags (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

CREATE INDEX index_posts_tags_tag_id ON public.posts_tags (tag_id) TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.posts_tags
    OWNER to postgres;

ALTER TABLE IF EXISTS public.posts_tags
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.posts_tags TO anon;

GRANT ALL ON TABLE public.posts_tags TO authenticated;

GRANT ALL ON TABLE public.posts_tags TO postgres;

GRANT ALL ON TABLE public.posts_tags TO service_role;
CREATE POLICY "Enable insert for authenticated users only"
    ON public.posts_tags
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (true);
CREATE POLICY "Enable read access for all users"
    ON public.posts_tags
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.medias
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    user_id uuid NOT NULL,
    type text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT medias_pkey PRIMARY KEY (id),
    CONSTRAINT medias_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

CREATE INDEX index_medias_user_id ON public.medias (user_id) TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.medias
    OWNER to postgres;

ALTER TABLE IF EXISTS public.medias
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.medias TO anon;

GRANT ALL ON TABLE public.medias TO authenticated;

GRANT ALL ON TABLE public.medias TO postgres;

GRANT ALL ON TABLE public.medias TO service_role;
CREATE POLICY "Enable insert for users based on user_id"
    ON public.medias
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = user_id));
CREATE POLICY "Enable read access for all users"
    ON public.medias
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.media_assets
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    media_id bigint NOT NULL,
    label text COLLATE pg_catalog."default" NOT NULL,
    mime_type text COLLATE pg_catalog."default" NOT NULL,
    path text COLLATE pg_catalog."default" NOT NULL,
    url text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT media_assets_pkey PRIMARY KEY (id),
    CONSTRAINT media_assets_media_id_fkey FOREIGN KEY (media_id)
        REFERENCES public.medias (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

CREATE INDEX index_media_assets_media_id ON public.media_assets (media_id) TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.media_assets
    OWNER to postgres;

ALTER TABLE IF EXISTS public.media_assets
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.media_assets TO anon;

GRANT ALL ON TABLE public.media_assets TO authenticated;

GRANT ALL ON TABLE public.media_assets TO postgres;

GRANT ALL ON TABLE public.media_assets TO service_role;
CREATE POLICY "Enable insert for authenticated users only"
    ON public.media_assets
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (true);
CREATE POLICY "Enable read access for all users"
    ON public.media_assets
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.attachments
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    post_id bigint NOT NULL,
    media_id bigint NOT NULL,
    CONSTRAINT attachments_pkey PRIMARY KEY (id),
    CONSTRAINT attachments_media_id_fkey FOREIGN KEY (media_id)
        REFERENCES public.medias (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    CONSTRAINT attachments_post_id_fkey FOREIGN KEY (post_id)
        REFERENCES public.posts (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.attachments
    OWNER to postgres;

ALTER TABLE IF EXISTS public.attachments
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.attachments TO anon;

GRANT ALL ON TABLE public.attachments TO authenticated;

GRANT ALL ON TABLE public.attachments TO postgres;

GRANT ALL ON TABLE public.attachments TO service_role;
CREATE POLICY "Enable insert for authenticated users only"
    ON public.attachments
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (true);
CREATE POLICY "Enable read access for all users"
    ON public.attachments
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
